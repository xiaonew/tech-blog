## 原型模式-继承


### 原型链-继承

ECMAScript中描述了原型链,并将原型链作为实现继承的主要方法.基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。这句话比较晦涩难理解，直接看代码。

``` javascript

    function Super() {
        this.superProperty = false;
    }


    Super.prototype.getSuperProperty = function () {
        return this.superProperty;
    }


    function Sub() {
        this.subProperty = true;
    }

    //这句话一定要在Sub.prototype = new Super()后面写，否则被覆盖
    Sub.prototype.getSubProperty = function () {
        return this.subProperty;
    }

    Sub.prototype = new Super();
    var sub = new Sub();
    console.log(sub.getSuperProperty());
    //Sub.prototype就是Super实例,sub的原型
    console.log(Sub.prototype.isPrototypeOf(sub));
    //Super.prototype是Super实例的原型,相当于Super实例继承Super,prototype,而Sub继承Super实例,所以也正确
    console.log(Super.prototype.isPrototypeOf(sub));
    //可以看出Sub的prototype就是Super实例,Sub.prototype
    console.log(Object.getPrototypeOf(sub) == Sub.prototype);

```

上述代码中,想实现Sub继承Super.通过`Sub.prototype = new Super()`实现。

**构造函数原型实例之间的关系**

![](https://raw.githubusercontent.com/xiaonew/tech-blog/master/img/4_1.png)

![](https://raw.githubusercontent.com/xiaonew/tech-blog/master/img/4_2.png)

可以看到原型链之间的关系:

```
Sub实例
    subProperty
    __proto__ =  Super实例
        superProperty
        __proto__ = Super原型
            getSuperProperty()
            __proto__ = Object 原型
                hasOwnProperty
                ...
                __proto__ =undefined

```

上面就是代码的原型链,当查找一个属性的时候,会沿着原型链进行查找,如果没有查找到，沿着原型链向上查找,直到查到Object.__proto__ 如果还没查找到，则返回undefined.

**原型链实现继承的问题:**

1.和使用原型创建对象一样,如果是引用类型,会导致属性共享,影响多个实例之间的属性值
2.不想向超类型的构造函数中传递参数



### 借用构造函数

使用call或者apply,把父构造函数当做普通的函数调用即可。改变其执行的作用域

``` javascript

    function Super(name) {
        this.name = name;

        this.sayName = function () {
            console.log(this.name);
        }
    }

    function Sub(name, age) {
        Super.call(this, name);
        this.age = age;
    }

    var sub = new Sub('小明',23);
    //小明
    sub.sayName();

```


上述`Sub`的构造函数相当于

``` javascript
 function Sub(name, age) {
        this.name = name;
        this.sayName = functio(){
            console.log(this.name)
        };
        this.age = age;
  }
```

**借用构造函数问题**

1.既然使用的时构造函数,那么就没法复用方法和属性











