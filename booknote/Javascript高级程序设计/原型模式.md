##  原型模式

在Javascript中一切皆是对象,所以我们会创建很多对象。那么就来看看创建对象的方法.原型模式也是解决创建对象的问题的。解决了什么问题,首先看下面几种创建对象模式所带来的问题。

### 工厂模式

``` javascript

    function createPerson(name,age){
        var obj = new Object();
        obj.name = name;
        obj.age = age;
        obj.sayName = function(){
            console.log(this.name);
        }
        return obj;
    }

    var  person1= createPerson('p1', 20);
    var  person2= createPerson('p2', 30);

```


用函数封装创建对象的细节。当做普通函数使用,返回创建的对象。

**问题:**

这样创建的对象无法区分出来类别。比如又有一个动物对象的工厂,和这个完全一样，根本无法区别。



### 构造函数模式

``` javascript

    function Person(name,age){
        this.name = name;
        this.age = age;
        this.sayName = function(){
            console.log(this.name);
        }
    }

    var person1 = new Person('p1', 20);
    var person2 = new Person('p2', 30);
    console.log(person1.constructor == Person);//true
    console.log(person1 instanceof  Person)//true

```

和工厂模式的区别,Person不再是一个普通函数,而是一个构造函数,外面显示调用new,创建对象,而且解决了工厂模式带来的问题,但是产生了新的问题。

**问题**

大家都知道js中一切皆对象,那么上述的sayName方法,每个对象都自己独有一个。那么可不可以做到对象可以共享方法和属性呢


### 原型模式

``` javascript

    function Person(){}
    Person.prototype.name = "pl";
    Person.prototype.age = 20;
    Person.prototype.sayName = function(){
        console.log(this.name);
    }

    var person1 = new Person();
    var person2 = new Person();
    person1.sayName();//pl
    person2.sayName();//pl
    
```







